<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ðŸ’£ Bomb Defusal</title>
  <script src="https://portals-labs.github.io/portals-sdk/portals-sdk.js?v=10005456"></script>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    
    body {
      font-family: 'Courier New', monospace;
      background: #0a0a0a;
      color: #00ff41;
      overflow: hidden;
      height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    
    #game-container {
      width: 100vw;
      height: 100vh;
      position: relative;
      background: radial-gradient(circle at 50% 30%, #1a1a1a 0%, #000 100%);
    }
    
    #header {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 28px;
      text-shadow: 0 0 15px #ff0040;
      letter-spacing: 2px;
    }
    
    #timer {
      position: absolute;
      top: 65px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 24px;
      color: #ffff00;
      text-shadow: 0 0 12px #ffff00;
      font-weight: bold;
    }
    
    #status {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 40px;
      text-shadow: 0 0 20px currentColor;
      min-width: 250px;
      pointer-events: none;
      letter-spacing: 3px;
    }
    
    #controls {
      position: absolute;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 20px;
    }
    
    button {
      padding: 12px 24px;
      background: linear-gradient(145deg, #1a1a1a, #0a0a0a);
      color: #00ff41;
      border: 2px solid #00ff41;
      border-radius: 4px;
      font-family: inherit;
      font-size: 16px;
      cursor: pointer;
      transition: all 0.3s;
      text-shadow: 0 0 5px #00ff41;
      letter-spacing: 1px;
    }
    
    button:hover {
      background: linear-gradient(145deg, #00ff41, #00cc33);
      color: #000;
      box-shadow: 0 0 15px #00ff41;
      transform: scale(1.05);
    }
    
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    canvas {
      width: 100vw;
      height: 100vh;
      cursor: crosshair;
      display: block;
    }
    
    .success { color: #00ff41 !important; animation: successGlow 1s infinite alternate; }
    .fail { color: #ff0040 !important; animation: failGlow 0.5s infinite alternate; }
    
    @keyframes successGlow { 
      from { text-shadow: 0 0 15px #00ff41; }
      to { text-shadow: 0 0 30px #00ff41, 0 0 40px #00ff41; }
    }
    @keyframes failGlow { 
      from { text-shadow: 0 0 15px #ff0040; }
      to { text-shadow: 0 0 30px #ff0040, 0 0 40px #ff0040; }
    }
  </style>
</head>
<body>
  <div id="game-container">
    <div id="header">ðŸ’£ DEFUSE THE BOMB</div>
    <div id="timer">TIME: 60s</div>
    <div id="status"></div>
    <div id="controls">
      <button id="resetBtn" onclick="resetGame()">RESET</button>
      <button onclick="closeIframe()">EXIT</button>
    </div>
    <canvas id="wire-canvas"></canvas>
  </div>

  <script>
    const TASK_NAME = "bombgame";
    const COLORS = ['#ff0040', '#4169e1', '#00ff41', '#ffff00'];
    const WIRE_POSITIONS = 4;

    let leftWires = [...COLORS];
    let rightWires = shuffle([...COLORS]);
    let connections = {};
    let dragging = null;
    let tempLine = null;
    let timer;
    let timeLeft = 60;
    let gameOver = false;
    let currentState = "NotActive"; // Track task state

    const canvas = document.getElementById('wire-canvas');
    const ctx = canvas.getContext('2d');
    let canvasWidth, canvasHeight;

    // PORTALS TASK STATE MAPPING
    const STATE_ACTIONS = {
      // Start: Make task active
      "SetNotActiveToActive": () => {
        currentState = "Active";
        resetGame();
      },
      // Success: Complete task
      "SetActiveToCompleted": () => {
        currentState = "Completed";
        endGame(true);
      },
      // Fail: Reset to active (try again)
      "SetCompletedToActive": () => {
        currentState = "Active";
        resetGame();
      },
      // Fail: Hide task temporarily
      "SetActiveToNotActive": () => {
        currentState = "NotActive";
        PortalsSdk.closeIframe();
      },
      // Universal complete (skip/straight to win)
      "SetAnyToCompleted": () => {
        currentState = "Completed";
        endGame(true);
      },
      // Universal activate
      "SetAnyToActive": () => {
        currentState = "Active";
        resetGame();
      }
    };

    function resizeCanvas() {
      canvasWidth = canvas.width = window.innerWidth;
      canvasHeight = canvas.height = window.innerHeight;
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    canvas.addEventListener('mousedown', handleMouseDown);
    canvas.addEventListener('mousemove', handleMouseMove);
    canvas.addEventListener('mouseup', handleMouseUp);
    canvas.addEventListener('touchstart', handleTouchStart);
    canvas.addEventListener('touchmove', handleTouchMove);
    canvas.addEventListener('touchend', handleTouchEnd);

    // Listen for Unity messages
    window.addEventListener('message', (event) => {
      if (event.data && event.data.type === 'unityMessage') {
        const action = STATE_ACTIONS[event.data.state];
        if (action) action();
      }
    });

    function shuffle(array) {
      return [...array].sort(() => Math.random() - 0.5);
    }

    function sendToUnity(targetState) {
      PortalsSdk.sendMessageToUnity(JSON.stringify({
        TaskName: TASK_NAME,
        TaskTargetState: targetState
      }));
    }

    function drawWires() {
      ctx.clearRect(0, 0, canvasWidth, canvasHeight);
      
      const centerY = canvasHeight * 0.5;
      const wireSpacing = canvasHeight * 0.15;
      const leftX = canvasWidth * 0.25;
      const rightX = canvasWidth * 0.75;
      const wireRadius = 22;

      // Draw metal panel background
      ctx.fillStyle = '#1a1a1a';
      ctx.fillRect(0, 0, canvasWidth, canvasHeight);
      
      // Draw warning stripes
      ctx.fillStyle = '#ff0040';
      for (let i = 0; i < canvasHeight; i += 40) {
        ctx.fillRect(canvasWidth * 0.1, i, canvasWidth * 0.05, 20);
        ctx.fillRect(canvasWidth * 0.85, i + 20, canvasWidth * 0.05, 20);
      }

      // Draw bomb body
      const bombX = canvasWidth * 0.5;
      const bombY = centerY;
      const bombWidth = 120;
      const bombHeight = 80;
      
      ctx.fillStyle = '#333';
      ctx.fillRect(bombX - bombWidth/2, bombY - bombHeight/2, bombWidth, bombHeight);
      
      ctx.fillStyle = '#444';
      ctx.beginPath();
      ctx.arc(bombX, bombY - bombHeight/2, bombWidth/2, Math.PI, 0);
      ctx.fill();
      
      ctx.beginPath();
      ctx.arc(bombX, bombY + bombHeight/2, bombWidth/2, 0, Math.PI);
      ctx.fill();
      
      // Red danger stripe
      ctx.fillStyle = '#ff0040';
      ctx.fillRect(bombX - bombWidth/2 + 5, bombY - 5, bombWidth - 10, 10);
      
      // Bomb label
      ctx.fillStyle = '#ffff00';
      ctx.font = 'bold 16px Courier New';
      ctx.textAlign = 'center';
      ctx.fillText('DANGER', bombX, bombY + 5);
      ctx.fillStyle = '#ff0040';
      ctx.fillText('EXPLOSIVE', bombX, bombY + 20);

      // Timer display on bomb
      ctx.fillStyle = '#000';
      ctx.fillRect(bombX - 30, bombY - 35, 60, 25);
      ctx.fillStyle = '#ffff00';
      ctx.font = 'bold 14px Courier New';
      ctx.fillText(timeLeft.toString().padStart(2, '0'), bombX, bombY - 20);

      // Sparks if low time
      if (timeLeft < 15) {
        ctx.fillStyle = '#ffff00';
        for (let i = 0; i < 5; i++) {
          const sparkX = bombX + (Math.random() - 0.5) * bombWidth;
          const sparkY = bombY - bombHeight/2 + Math.random() * 10;
          ctx.beginPath();
          ctx.arc(sparkX, sparkY, Math.random() * 2 + 1, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      // Draw left wire terminals
      for (let i = 0; i < WIRE_POSITIONS; i++) {
        const y = centerY - (WIRE_POSITIONS - 1) * wireSpacing / 2 + i * wireSpacing;
        const color = leftWires[i];
        
        ctx.fillStyle = '#222';
        ctx.beginPath();
        ctx.arc(leftX, y, wireRadius + 5, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(leftX, y, wireRadius, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.stroke();
        
        ctx.shadowColor = color;
        ctx.shadowBlur = 20;
        ctx.fill();
        ctx.shadowBlur = 0;
        
        if (connections[i] !== undefined) {
          const rightIndex = connections[i];
          const rightY = centerY - (WIRE_POSITIONS - 1) * wireSpacing / 2 + rightIndex * wireSpacing;
          ctx.strokeStyle = color;
          ctx.lineWidth = 8;
          ctx.beginPath();
          ctx.moveTo(leftX + wireRadius, y);
          ctx.quadraticCurveTo(bombX - bombWidth/2, y, bombX - bombWidth/2 + 10, rightY);
          ctx.quadraticCurveTo(bombX - bombWidth/2 + 20, rightY, rightX - wireRadius, rightY);
          ctx.stroke();
        }
      }

      // Draw right wire terminals
      for (let i = 0; i < WIRE_POSITIONS; i++) {
        const y = centerY - (WIRE_POSITIONS - 1) * wireSpacing / 2 + i * wireSpacing;
        const color = rightWires[i];
        
        ctx.fillStyle = '#222';
        ctx.beginPath();
        ctx.arc(rightX, y, wireRadius + 5, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(rightX, y, wireRadius, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.stroke();
        
        ctx.shadowColor = color;
        ctx.shadowBlur = 20;
        ctx.fill();
        ctx.shadowBlur = 0;
      }

      // Temp drag line
      if (tempLine && dragging !== null) {
        const startY = centerY - (WIRE_POSITIONS - 1) * wireSpacing / 2 + dragging * wireSpacing;
        ctx.strokeStyle = leftWires[dragging];
        ctx.lineWidth = 6;
        ctx.setLineDash([8, 8]);
        ctx.beginPath();
        ctx.moveTo(leftX + wireRadius, startY);
        ctx.quadraticCurveTo(bombX - bombWidth/2, startY, tempLine.x, tempLine.y);
        ctx.stroke();
        ctx.setLineDash([]);
      }
    }

    function startTimer() {
      timer = setInterval(() => {
        timeLeft--;
        document.getElementById('timer').textContent = `TIME: ${timeLeft}s`;
        if (timeLeft <= 0) endGame(false);
        drawWires();
      }, 1000);
    }

    function getMousePos(e) {
      const rect = canvas.getBoundingClientRect();
      return {
        x: (e.clientX || e.touches[0].clientX) - rect.left,
        y: (e.clientY || e.touches[0].clientY) - rect.top
      };
    }

    function handleMouseDown(e) { handleStart(getMousePos(e)); }
    function handleTouchStart(e) { e.preventDefault(); handleStart(getMousePos(e)); }
    
    function handleStart(pos) {
      if (gameOver) return;
      const centerY = canvasHeight * 0.5;
      const wireSpacing = canvasHeight * 0.15;
      const leftX = canvasWidth * 0.25;
      const wireRadius = 22;

      for (let i = 0; i < WIRE_POSITIONS; i++) {
        const y = centerY - (WIRE_POSITIONS - 1) * wireSpacing / 2 + i * wireSpacing;
        const dist = Math.hypot(pos.x - leftX, pos.y - y);
        if (dist < wireRadius && connections[i] === undefined) {
          dragging = i;
          tempLine = { x: pos.x, y: pos.y };
          canvas.style.cursor = 'grabbing';
          break;
        }
      }
    }

    function handleMouseMove(e) { if (dragging !== null) handleMove(getMousePos(e)); }
    function handleTouchMove(e) { e.preventDefault(); if (dragging !== null) handleMove(getMousePos(e)); }
    
    function handleMove(pos) {
      if (dragging === null) return;
      tempLine = pos;
      drawWires();
    }

    function handleMouseUp(e) { handleEnd(getMousePos(e)); }
    function handleTouchEnd(e) { handleEnd(getMousePos(e)); }
    
    function handleEnd(pos) {
      if (dragging === null) return;
      
      const centerY = canvasHeight * 0.5;
      const wireSpacing = canvasHeight * 0.15;
      const rightX = canvasWidth * 0.75;
      const wireRadius = 22;

      let connected = false;
      for (let i = 0; i < WIRE_POSITIONS; i++) {
        const y = centerY - (WIRE_POSITIONS - 1) * wireSpacing / 2 + i * wireSpacing;
        const dist = Math.hypot(pos.x - rightX, pos.y - y);
        if (dist < wireRadius && !Object.values(connections).includes(i)) {
          if (leftWires[dragging] === rightWires[i]) {
            connections[dragging] = i;
            connected = true;
            checkWin();
          }
          break;
        }
      }

      dragging = null;
      tempLine = null;
      canvas.style.cursor = 'crosshair';
      drawWires();
    }

    function checkWin() {
      if (Object.keys(connections).length === WIRE_POSITIONS) {
        endGame(true);
      }
    }

    function endGame(success) {
      gameOver = true;
      clearInterval(timer);
      const status = document.getElementById('status');
      const resetBtn = document.getElementById('resetBtn');
      
      if (success) {
        // SUCCESS: Active â†’ Completed
        status.textContent = 'DEFUSED';
        status.className = 'success';
        sendToUnity("SetActiveToCompleted");
        setTimeout(() => PortalsSdk.closeIframe(), 2500);
      } else {
        // FAIL: Active â†’ Completed (allow retry in Unity)
        status.textContent = 'EXPLODED';
        status.className = 'fail';
        sendToUnity("SetActiveToCompleted");
        resetBtn.disabled = false;
      }
    }

    function resetGame() {
      rightWires = shuffle(COLORS);
      connections = {};
      dragging = null;
      tempLine = null;
      timeLeft = 60;
      gameOver = false;
      document.getElementById('status').textContent = '';
      document.getElementById('status').className = '';
      document.getElementById('timer').textContent = `TIME: ${timeLeft}s`;
      document.getElementById('resetBtn').disabled = true;
      clearInterval(timer);
      startTimer();
      drawWires();
    }

    function closeIframe() {
      // Send current state before closing
      sendToUnity(currentState === "Active" ? "SetActiveToNotActive" : "SetCompletedToNotActive");
      PortalsSdk.closeIframe();
    }

    // Start game
    drawWires();
    startTimer();
    document.getElementById('resetBtn').disabled = true;
  </script>
</body>
</html>